/* autogenerated by Processing revision 1277 on 2022-01-05 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import uibooster.*;
import uibooster.components.*;
import uibooster.model.*;
import uibooster.model.formelements.*;
import uibooster.model.options.*;
import uibooster.utils.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Boids extends PApplet {












class Flock{
 
  ArrayList<Boid> boids;
  
  Flock()
  {
     boids = new ArrayList(); 
  }
  
   public void addBoid()
  {
    boids.add(new Boid());
  }
   public Boid getBoid(int num){
   return boids.get(num);
  }
  
   public float getSize(){
   return boids.size(); 
  }
  
}


//***************Variable declarations****************
final int SIZE = 7;
//final float perceptionRadius = 100;
final int MAX_SPEED = 10;
final float MAX_FORCE = 1;
final int barWidth = 100;

Flock f;
Boid b;


  int button1X,button1Y; // perception radius button
  int button2X,button2Y; // cohesion enable button
  int button3X,button3Y; // alignment enable button
  int button4X,button4Y; // separation enable button
  int button5X,button5Y;
  int buttonWidth = 80,buttonHeight = 30; 
  int buttonDistance = 50;// the distance between buttons - in pixels
  
float displacementSize = 5;  
  
boolean cohesionEnable;
boolean alignmentEnable;
boolean separationEnable;
boolean boundaryEnable;


int numOfBoids = 10;
  
//*****************************************************




class Boid{
   
   PVector position;
   PVector velocity;
   PVector acceleration;
   int perceptionRadius = 50;
   boolean clicked = false;
  
  Boid(){
      position = new PVector(random(width-barWidth), random(height));
      velocity = new PVector(random(10),random(10));
      acceleration = new PVector();
  }
  
   public void display()
  {
    noStroke();
    fill(204);
    if(clicked){
      noFill();
      stroke(255);
      ellipse(position.x,position.y,perceptionRadius*2,perceptionRadius*2); 
      fill(255,0,0);
    }else{
      fill(153);
    }
    ellipse(position.x,position.y,SIZE,SIZE);
    stroke(255);
    line(position.x,position.y,position.x+velocity.x*2,position.y+velocity.y*2);
    
    
  }
  
   public void update(){
    position.add(velocity);
    avoidBoundary();
    velocity.add(acceleration);
    velocity.limit(MAX_SPEED);
    acceleration.mult(0);
    //print(position.x+" , "+position.y+"\n");
    
  }

  
   public void updatePerceptionRadius(int num){
   perceptionRadius = num; 
  }
   public void avoidBoundary(){
    if(!boundaryEnable){
      
   if(position.x>width-barWidth){
    //velocity.x*=-1;
    position.x = 0;
   }else if(position.x<0){
     //velocity.x*=-1;
     position.x = width-barWidth;
   }
    if(position.y>height){
       //velocity.y*=-1;
       position.y = 0;
    }
    else if(position.y<0){
      //velocity.y*=-1;
      position.y = height;
    }
    }
    else{
      
       if(position.x>width-barWidth){
    velocity.x*=-1;
    
   }else if(position.x<0){
     velocity.x*=-1;
    
   }
    if(position.y>height){
       velocity.y*=-1;
       
    }
    else if(position.y<0){
      velocity.y*=-1;
      
    }
      
      
    }
    
  }
  
   public PVector alignment(Flock fl)
  {
   PVector steer = new PVector(); 
    int num = 0;
    for(int i = 0; i<fl.getSize(); i++){
      Boid other = fl.getBoid(i);
      float distance = dist(position.x,position.y,other.position.x,other.position.y);
      if(other!=this&&distance<perceptionRadius){
        steer.add(other.velocity);
        num++;
      }
      if(num>0){
        steer.div(num);
       
        steer.setMag(MAX_SPEED);
        steer.sub(velocity);
        steer.limit(MAX_FORCE);
      }
      
    }
    return steer;
    
    
  }
  
  
   public PVector cohesion(Flock fl){
   PVector steer = new PVector();
   int num = 0;
   
   for(int i =0; i<fl.getSize(); i++){
     Boid other = fl.getBoid(i);
     float distance = dist(position.x,position.y,other.position.x,other.position.y);
     if(other!=this&&distance<perceptionRadius){
       
      steer.add(other.position);
      num++;
     }
   }
   
   
     if(num>0){
      steer.div(num);
      print("average: "+steer.x+", "+steer.y+"\n");
      steer.sub(position);
      steer.setMag(MAX_SPEED);
      
      steer.sub(velocity);
      steer.limit(MAX_FORCE);
       print(steer.x+" "+steer.y+"\n");
     
     
   }
    
    return steer;
    
    
    
  }
  
   public PVector separation(Flock fl){
    
    PVector steer = new PVector();
    PVector diff = new PVector();
    PVector temp;
    int num = 0;
    for(int i= 0; i<fl.getSize();i++){
     Boid other = fl.getBoid(i);
     float distance = dist(position.x,position.y,other.position.x,other.position.y);
     if(other!=this&&distance<perceptionRadius){
      diff.mult(0);
      temp = position.copy();
      diff.add(temp.sub(other.position));
      diff.div(distance);
      steer.add(diff);
      num++;
       
     }     
    }
    if(num>0){
     steer.div(num);
     steer.setMag(MAX_SPEED);
     steer.sub(velocity);
     steer.limit(MAX_FORCE);
      
    }
    
    
    
   return steer; 
  }
   public void flock(Flock fl){
    PVector align = alignment(fl);
    PVector c = cohesion(fl);
    PVector s = separation(fl);
    if(alignmentEnable){
      acceleration.add(align);  
    }
    if(cohesionEnable){
      acceleration.add(c);  
    }
    if(separationEnable)
      acceleration.add(s);
    
  }
  
  
}


 public void setup()
{
   background(51);
   /* size commented out by preprocessor */;
   noStroke();
   frameRate(30);
   
   
   cohesionEnable = false;
   alignmentEnable = false;
   separationEnable = false;
   boidsSlider();
   
   f = new Flock();
  for(int i = 0; i<numOfBoids; i++){
      f.addBoid();
    
  }
  
  //--------button coords------------
   button1X = width-barWidth+15;
   button1Y = 30;
   button2X = button1X;
   button3X = button1X;
   button4X = button1X;
   button5X = button1X;
   button2Y = button1Y+buttonDistance;
   button3Y = button2Y+buttonDistance;
   button4Y = button3Y+buttonDistance;
   button5Y = button4Y+buttonDistance;
  //---------------------------------
  
  
  
}



 public void draw(){
  
  background(51);
   fill(128);
   rect(width-barWidth,0,barWidth,height,50,0,0,50);
   fill(255,0,0);
   rect(button1X,button1Y,buttonWidth,buttonHeight,10,10,10,10);
   if(cohesionEnable)
     fill(0,255,0);
     else
       fill(255,0,0);
   rect(button2X,button2Y,buttonWidth,buttonHeight,10,10,10,10);
   if(alignmentEnable)
     fill(0,255,0);
     else
       fill(255,0,0);
   rect(button3X,button3Y,buttonWidth,buttonHeight,10,10,10,10);
   if(separationEnable)
     fill(0,255,0);
     else
       fill(255,0,0);
   rect(button4X,button4Y,buttonWidth,buttonHeight,10,10,10,10);
   if(boundaryEnable)
     fill(0,255,0);
     else
       fill(255,0,0);
   rect(button5X,button5Y,buttonWidth,buttonHeight,10,10,10,10);
   
   textSize(15);
   fill(255,255,255);
   text("P Radius",button1X+5,50);
   text("Cohesion",button2X+5,button2Y+20);
   text("Alignment",button3X+5,button3Y+20);
   text("Separation",button4X+5,button4Y+20);
   text("Boundary",button5X+5,button5Y+20);
  for(int i = 0; i<numOfBoids; i++){
    f.getBoid(i).flock(f);
    f.getBoid(i).update();
    f.getBoid(i).display();
    
  }
  

}

 public void boidsSlider(){
    try{
  int num = new UiBooster().showSlider("Number of boids","Boids ",0,100,40,10,10);
  numOfBoids = num;
  }catch(Exception e){
   e.printStackTrace(); 
  }
  
}
 public void radiusSlider()
{
  try{
  int rad = new UiBooster().showSlider("Perception Radius Slider","P Radius ",0,300,50,50,10);
  for(int i =0; i<f.getSize(); i++){
     Boid other = f.getBoid(i);
     if(rad>-1){
       other.updatePerceptionRadius(rad);
     }
      
  }
}catch(Exception e){
   e.printStackTrace(); 
}
    
}



   public void mouseClicked(){
    
    
    if(mouseX>button1X&&mouseX<button1X+buttonWidth)
      {
       if(mouseY>button1Y&&mouseY<button1Y+buttonHeight){
        thread("radiusSlider");
        return;
       }
      }
     if(mouseX>button2X&&mouseX<button2X+buttonWidth)
      {
       if(mouseY>button2Y&&mouseY<button2Y+buttonHeight){
          cohesionEnable=!cohesionEnable;
        return;
       }
      }
        if(mouseX>button3X&&mouseX<button3X+buttonWidth)
      {
       if(mouseY>button3Y&&mouseY<button3Y+buttonHeight){
          alignmentEnable=!alignmentEnable;
        return;
       }
      }
        if(mouseX>button4X&&mouseX<button4X+buttonWidth)
      {
       if(mouseY>button4Y&&mouseY<button4Y+buttonHeight){
          separationEnable=!separationEnable;
        return;
       }
      }
      if(mouseX>button5X&&mouseX<button5X+buttonWidth)
      {
       if(mouseY>button5Y&&mouseY<button5Y+buttonHeight){
          boundaryEnable=!boundaryEnable;
        return;
       }
      }
    
    for(int i = 0; i<f.getSize(); i++){
      Boid boid = f.getBoid(i);
      if(abs(mouseX-boid.position.x)<SIZE&&abs(mouseY-boid.position.y)<SIZE){
        boid.clicked = true;
        return;
      }else
      boid.clicked = false;
    }
   
  }


  public void settings() { size(1400, 1300); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Boids" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
